#ifndef TMB_H
#define TMB_H
#ifdef TMB_PRECOMPILE
/** \file
    \brief Include this file to extract declarations, definitions and selected code for pre-compilation
*/
#undef WITH_LIBTMB
#undef TMB_PRECOMPILE
#undef CSKIP
#undef IF_TMB_PRECOMPILE
#undef TMB_EXTERN
// Redefine
#undef  WITH_LIBTMB
#define TMB_PRECOMPILE
#define CSKIP(...) __VA_ARGS__
#define IF_TMB_PRECOMPILE(...) __VA_ARGS__
#define TMB_EXTERN
#else
/** \file
    \brief Include this file to extract declarations only
*/
#undef WITH_LIBTMB
#undef TMB_PRECOMPILE
#undef CSKIP
#undef IF_TMB_PRECOMPILE
#undef TMB_EXTERN
// Redefine
#define WITH_LIBTMB
#undef  TMB_PRECOMPILE
#define CSKIP(...) ;
#define IF_TMB_PRECOMPILE(...)
#define TMB_EXTERN extern
#endif
#include <TMB.hpp>
#ifdef CPPAD_FRAMEWORK
// Autogenerated - do not edit by hand
//
// -DWITH_LIBTMB    : Extracts header declarations only.
// -DTMB_PRECOMPILE : Instantiations for precompilation.
namespace density {
#undef TYPEDEFS
#undef VARIANCE_NOT_YET_IMPLEMENTED
#undef SIMULATE_NOT_YET_IMPLEMENTED
#undef SIMULATE_IMPLEMENTED_UNKNOWN_SIZE
#undef SIMULATE_IMPLEMENTED_KNOWN_SIZE
#define TYPEDEFS(scalartype_)public:typedef scalartype_ scalartype;typedef vector<scalartype> vectortype;typedef matrix<scalartype> matrixtype;typedef array<scalartype> arraytype
#define VARIANCE_NOT_YET_IMPLEMENTED            private:                                        vectortype variance(){return vectortype();}     public:
#define SIMULATE_NOT_YET_IMPLEMENTED            private:                                        vectortype sqrt_cov_scale(vectortype x){}       void simulate(vectortype &u){}                  vectortype simulate(){}                         public:
#define SIMULATE_IMPLEMENTED_UNKNOWN_SIZE       void simulate(vectortype &x) {                    rnorm_fill(x);                                  x = sqrt_cov_scale(x);                          x = zero_derivatives(x);                      }
#define SIMULATE_IMPLEMENTED_KNOWN_SIZE(SIZE)   SIMULATE_IMPLEMENTED_UNKNOWN_SIZE               vectortype simulate() {                           vectortype x(SIZE);                             simulate(x);                                    return x;                                     }
#ifdef WITH_LIBTMB
template <>
class MVNORM_t<double >{
  TYPEDEFS(double );
  matrixtype Q;
  scalartype logdetQ;
  matrixtype Sigma;
  matrixtype L_Sigma;
public:
  MVNORM_t();
  MVNORM_t(matrixtype Sigma_, bool use_atomic=true);
  matrixtype cov();
  void setSigma(matrixtype Sigma_, bool use_atomic=true);
  scalartype Quadform(vectortype x);
  scalartype operator()(vectortype x);
  scalartype operator()(vectortype x, vectortype keep);
  arraytype jacobian(arraytype x);
  int ndim();
  VARIANCE_NOT_YET_IMPLEMENTED
  vectortype sqrt_cov_scale(vectortype u) ;
  SIMULATE_IMPLEMENTED_KNOWN_SIZE(Sigma.rows());
};
template <>
class MVNORM_t<CppAD::AD<double> >{
  TYPEDEFS(CppAD::AD<double> );
  matrixtype Q;
  scalartype logdetQ;
  matrixtype Sigma;
  matrixtype L_Sigma;
public:
  MVNORM_t();
  MVNORM_t(matrixtype Sigma_, bool use_atomic=true);
  matrixtype cov();
  void setSigma(matrixtype Sigma_, bool use_atomic=true);
  scalartype Quadform(vectortype x);
  scalartype operator()(vectortype x);
  scalartype operator()(vectortype x, vectortype keep);
  arraytype jacobian(arraytype x);
  int ndim();
  VARIANCE_NOT_YET_IMPLEMENTED
  vectortype sqrt_cov_scale(vectortype u) ;
  SIMULATE_IMPLEMENTED_KNOWN_SIZE(Sigma.rows());
};
template <>
class MVNORM_t<CppAD::AD<CppAD::AD<double> > >{
  TYPEDEFS(CppAD::AD<CppAD::AD<double> > );
  matrixtype Q;
  scalartype logdetQ;
  matrixtype Sigma;
  matrixtype L_Sigma;
public:
  MVNORM_t();
  MVNORM_t(matrixtype Sigma_, bool use_atomic=true);
  matrixtype cov();
  void setSigma(matrixtype Sigma_, bool use_atomic=true);
  scalartype Quadform(vectortype x);
  scalartype operator()(vectortype x);
  scalartype operator()(vectortype x, vectortype keep);
  arraytype jacobian(arraytype x);
  int ndim();
  VARIANCE_NOT_YET_IMPLEMENTED
  vectortype sqrt_cov_scale(vectortype u) ;
  SIMULATE_IMPLEMENTED_KNOWN_SIZE(Sigma.rows());
};
template <>
class MVNORM_t<CppAD::AD<CppAD::AD<CppAD::AD<double> > > >{
  TYPEDEFS(CppAD::AD<CppAD::AD<CppAD::AD<double> > > );
  matrixtype Q;
  scalartype logdetQ;
  matrixtype Sigma;
  matrixtype L_Sigma;
public:
  MVNORM_t();
  MVNORM_t(matrixtype Sigma_, bool use_atomic=true);
  matrixtype cov();
  void setSigma(matrixtype Sigma_, bool use_atomic=true);
  scalartype Quadform(vectortype x);
  scalartype operator()(vectortype x);
  scalartype operator()(vectortype x, vectortype keep);
  arraytype jacobian(arraytype x);
  int ndim();
  VARIANCE_NOT_YET_IMPLEMENTED
  vectortype sqrt_cov_scale(vectortype u) ;
  SIMULATE_IMPLEMENTED_KNOWN_SIZE(Sigma.rows());
};
template <>
class GMRF_t<double > {
  TYPEDEFS(double );
private:
  Eigen::SparseMatrix<scalartype> Q;
  scalartype logdetQ;
  int sqdist(vectortype x, vectortype x_) ;
public:
  GMRF_t();
  GMRF_t(Eigen::SparseMatrix<scalartype> Q_, int order_=1, bool normalize=true);
  GMRF_t(arraytype x, vectortype delta, int order_=1, bool normalize=true);
  void setQ(Eigen::SparseMatrix<scalartype> Q_, int order=1, bool normalize=true);
  scalartype Quadform(vectortype x);
  scalartype operator()(vectortype x);
  arraytype jacobian(arraytype x);
  int ndim() ;
  vectortype variance() ;
  Eigen::SparseMatrix<scalartype> L;
  Eigen::PermutationMatrix<Dynamic,Dynamic> Pinv;
  vectortype sqrt_cov_scale(vectortype u) ;
  SIMULATE_IMPLEMENTED_KNOWN_SIZE(Q.rows())
};
template <>
class GMRF_t<CppAD::AD<double> > {
  TYPEDEFS(CppAD::AD<double> );
private:
  Eigen::SparseMatrix<scalartype> Q;
  scalartype logdetQ;
  int sqdist(vectortype x, vectortype x_) ;
public:
  GMRF_t();
  GMRF_t(Eigen::SparseMatrix<scalartype> Q_, int order_=1, bool normalize=true);
  GMRF_t(arraytype x, vectortype delta, int order_=1, bool normalize=true);
  void setQ(Eigen::SparseMatrix<scalartype> Q_, int order=1, bool normalize=true);
  scalartype Quadform(vectortype x);
  scalartype operator()(vectortype x);
  arraytype jacobian(arraytype x);
  int ndim() ;
  vectortype variance() ;
  Eigen::SparseMatrix<scalartype> L;
  Eigen::PermutationMatrix<Dynamic,Dynamic> Pinv;
  vectortype sqrt_cov_scale(vectortype u) ;
  SIMULATE_IMPLEMENTED_KNOWN_SIZE(Q.rows())
};
template <>
class GMRF_t<CppAD::AD<CppAD::AD<double> > > {
  TYPEDEFS(CppAD::AD<CppAD::AD<double> > );
private:
  Eigen::SparseMatrix<scalartype> Q;
  scalartype logdetQ;
  int sqdist(vectortype x, vectortype x_) ;
public:
  GMRF_t();
  GMRF_t(Eigen::SparseMatrix<scalartype> Q_, int order_=1, bool normalize=true);
  GMRF_t(arraytype x, vectortype delta, int order_=1, bool normalize=true);
  void setQ(Eigen::SparseMatrix<scalartype> Q_, int order=1, bool normalize=true);
  scalartype Quadform(vectortype x);
  scalartype operator()(vectortype x);
  arraytype jacobian(arraytype x);
  int ndim() ;
  vectortype variance() ;
  Eigen::SparseMatrix<scalartype> L;
  Eigen::PermutationMatrix<Dynamic,Dynamic> Pinv;
  vectortype sqrt_cov_scale(vectortype u) ;
  SIMULATE_IMPLEMENTED_KNOWN_SIZE(Q.rows())
};
template <>
class GMRF_t<CppAD::AD<CppAD::AD<CppAD::AD<double> > > > {
  TYPEDEFS(CppAD::AD<CppAD::AD<CppAD::AD<double> > > );
private:
  Eigen::SparseMatrix<scalartype> Q;
  scalartype logdetQ;
  int sqdist(vectortype x, vectortype x_) ;
public:
  GMRF_t();
  GMRF_t(Eigen::SparseMatrix<scalartype> Q_, int order_=1, bool normalize=true);
  GMRF_t(arraytype x, vectortype delta, int order_=1, bool normalize=true);
  void setQ(Eigen::SparseMatrix<scalartype> Q_, int order=1, bool normalize=true);
  scalartype Quadform(vectortype x);
  scalartype operator()(vectortype x);
  arraytype jacobian(arraytype x);
  int ndim() ;
  vectortype variance() ;
  Eigen::SparseMatrix<scalartype> L;
  Eigen::PermutationMatrix<Dynamic,Dynamic> Pinv;
  vectortype sqrt_cov_scale(vectortype u) ;
  SIMULATE_IMPLEMENTED_KNOWN_SIZE(Q.rows())
};
#endif
#ifdef TMB_PRECOMPILE
template class MVNORM_t<double >;
template class MVNORM_t<CppAD::AD<double> >;
template class MVNORM_t<CppAD::AD<CppAD::AD<double> > >;
template class MVNORM_t<CppAD::AD<CppAD::AD<CppAD::AD<double> > > >;
template class GMRF_t<double >;
template class GMRF_t<CppAD::AD<double> >;
template class GMRF_t<CppAD::AD<CppAD::AD<double> > >;
template class GMRF_t<CppAD::AD<CppAD::AD<CppAD::AD<double> > > >;
#endif
#undef TYPEDEFS
#undef VARIANCE_NOT_YET_IMPLEMENTED
#undef SIMULATE_NOT_YET_IMPLEMENTED
#undef SIMULATE_IMPLEMENTED_UNKNOWN_SIZE
#undef SIMULATE_IMPLEMENTED_KNOWN_SIZE
}
#endif
#ifdef TMBAD_FRAMEWORK
// Autogenerated - do not edit by hand
//
// -DWITH_LIBTMB    : Extracts header declarations only.
// -DTMB_PRECOMPILE : Instantiations for precompilation.
namespace density {
#undef TYPEDEFS
#undef VARIANCE_NOT_YET_IMPLEMENTED
#undef SIMULATE_NOT_YET_IMPLEMENTED
#undef SIMULATE_IMPLEMENTED_UNKNOWN_SIZE
#undef SIMULATE_IMPLEMENTED_KNOWN_SIZE
#define TYPEDEFS(scalartype_)public:typedef scalartype_ scalartype;typedef vector<scalartype> vectortype;typedef matrix<scalartype> matrixtype;typedef array<scalartype> arraytype
#define VARIANCE_NOT_YET_IMPLEMENTED            private:                                        vectortype variance(){return vectortype();}     public:
#define SIMULATE_NOT_YET_IMPLEMENTED            private:                                        vectortype sqrt_cov_scale(vectortype x){}       void simulate(vectortype &u){}                  vectortype simulate(){}                         public:
#define SIMULATE_IMPLEMENTED_UNKNOWN_SIZE       void simulate(vectortype &x) {                    rnorm_fill(x);                                  x = sqrt_cov_scale(x);                          x = zero_derivatives(x);                      }
#define SIMULATE_IMPLEMENTED_KNOWN_SIZE(SIZE)   SIMULATE_IMPLEMENTED_UNKNOWN_SIZE               vectortype simulate() {                           vectortype x(SIZE);                             simulate(x);                                    return x;                                     }
#ifdef WITH_LIBTMB
template <>
class MVNORM_t<double >{
  TYPEDEFS(double );
  matrixtype Q;
  scalartype logdetQ;
  matrixtype Sigma;
  matrixtype L_Sigma;
public:
  MVNORM_t();
  MVNORM_t(matrixtype Sigma_, bool use_atomic=true);
  matrixtype cov();
  void setSigma(matrixtype Sigma_, bool use_atomic=true);
  scalartype Quadform(vectortype x);
  scalartype operator()(vectortype x);
  scalartype operator()(vectortype x, vectortype keep);
  arraytype jacobian(arraytype x);
  int ndim();
  VARIANCE_NOT_YET_IMPLEMENTED
  vectortype sqrt_cov_scale(vectortype u) ;
  SIMULATE_IMPLEMENTED_KNOWN_SIZE(Sigma.rows());
};
template <>
class MVNORM_t<TMBad::ad_aug >{
  TYPEDEFS(TMBad::ad_aug );
  matrixtype Q;
  scalartype logdetQ;
  matrixtype Sigma;
  matrixtype L_Sigma;
public:
  MVNORM_t();
  MVNORM_t(matrixtype Sigma_, bool use_atomic=true);
  matrixtype cov();
  void setSigma(matrixtype Sigma_, bool use_atomic=true);
  scalartype Quadform(vectortype x);
  scalartype operator()(vectortype x);
  scalartype operator()(vectortype x, vectortype keep);
  arraytype jacobian(arraytype x);
  int ndim();
  VARIANCE_NOT_YET_IMPLEMENTED
  vectortype sqrt_cov_scale(vectortype u) ;
  SIMULATE_IMPLEMENTED_KNOWN_SIZE(Sigma.rows());
};
template <>
class GMRF_t<double > {
  TYPEDEFS(double );
private:
  Eigen::SparseMatrix<scalartype> Q;
  scalartype logdetQ;
  int sqdist(vectortype x, vectortype x_) ;
public:
  GMRF_t();
  GMRF_t(Eigen::SparseMatrix<scalartype> Q_, int order_=1, bool normalize=true);
  GMRF_t(arraytype x, vectortype delta, int order_=1, bool normalize=true);
  void setQ(Eigen::SparseMatrix<scalartype> Q_, int order=1, bool normalize=true);
  scalartype Quadform(vectortype x);
  scalartype operator()(vectortype x);
  arraytype jacobian(arraytype x);
  int ndim() ;
  vectortype variance() ;
  Eigen::SparseMatrix<scalartype> L;
  Eigen::PermutationMatrix<Dynamic,Dynamic> Pinv;
  vectortype sqrt_cov_scale(vectortype u) ;
  SIMULATE_IMPLEMENTED_KNOWN_SIZE(Q.rows())
};
template <>
class GMRF_t<TMBad::ad_aug > {
  TYPEDEFS(TMBad::ad_aug );
private:
  Eigen::SparseMatrix<scalartype> Q;
  scalartype logdetQ;
  int sqdist(vectortype x, vectortype x_) ;
public:
  GMRF_t();
  GMRF_t(Eigen::SparseMatrix<scalartype> Q_, int order_=1, bool normalize=true);
  GMRF_t(arraytype x, vectortype delta, int order_=1, bool normalize=true);
  void setQ(Eigen::SparseMatrix<scalartype> Q_, int order=1, bool normalize=true);
  scalartype Quadform(vectortype x);
  scalartype operator()(vectortype x);
  arraytype jacobian(arraytype x);
  int ndim() ;
  vectortype variance() ;
  Eigen::SparseMatrix<scalartype> L;
  Eigen::PermutationMatrix<Dynamic,Dynamic> Pinv;
  vectortype sqrt_cov_scale(vectortype u) ;
  SIMULATE_IMPLEMENTED_KNOWN_SIZE(Q.rows())
};
#endif
#ifdef TMB_PRECOMPILE
template class MVNORM_t<double >;
template class MVNORM_t<TMBad::ad_aug >;
template class GMRF_t<double >;
template class GMRF_t<TMBad::ad_aug >;
#endif
#undef TYPEDEFS
#undef VARIANCE_NOT_YET_IMPLEMENTED
#undef SIMULATE_NOT_YET_IMPLEMENTED
#undef SIMULATE_IMPLEMENTED_UNKNOWN_SIZE
#undef SIMULATE_IMPLEMENTED_KNOWN_SIZE
}
#endif
#endif
